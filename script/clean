#!/usr/bin/env zsh
set -euo pipefail

# script/clean
# Usage:
#   ./script/clean --all        # process all files in taxi_log_2008_by_id
#   ./script/clean -n 16       # process single file taxi_log_2008_by_id/16.txt
# Output files are written to data/taxi_log_2008_by_id/<id>.txt

# Resolve script directory and repository root (parent of this script)
SCRIPT_DIR="$(cd "$(dirname "${0}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
SOURCEDIR="${REPO_ROOT}/taxi_log_2008_by_id"
OUTDIR="${REPO_ROOT}/data/taxi"

usage() {
  cat <<EOF
Usage: $0 [--all] | [-n ID]

Options:
  --all        Process all .txt files in ${SOURCEDIR}
  -n ID        Process single file ID (e.g. -n 16 -> ${SOURCEDIR}/16.txt)
  -h, --help   Show this message

  This script extracts the last two columns from comma-separated input,
computes their mean, recenters the coordinates to zero-mean, uniformly scales
them so the largest absolute coordinate equals 10000 (so points lie within
[-10000,10000]^2), and writes the cleaned file to ${OUTDIR}. The output
file begins with a single integer N on the first line (the number of points)
followed by N lines with "x y" (space-separated) coordinates.
EOF
}

process_file() {
  local in="$1"
  local base
  base=$(basename -- "$in")
  mkdir -p "${OUTDIR}"
  local out="${OUTDIR}/${base}"
  local tmp
  tmp="${out}.tmp.$$"

  # Extract the last two comma-separated fields, compute mean and emit
  # a zero-meaned point list prefixed with the count.
  awk -F',' '
    function trim(s) { gsub(/^\s+|\s+$/, "", s); return s }
    NF>=2 {
      x = trim($(NF-1)); y = trim($NF);
      n++; a[n] = x + 0; b[n] = y + 0;
    }
    END {
      if (n == 0) exit;
      mx = 0; my = 0;
      for (i = 1; i <= n; i++) { mx += a[i]; my += b[i] }
      mx /= n; my /= n;
      # compute max absolute coordinate after centering
      maxabs = 0;
      for (i = 1; i <= n; i++) {
        dx = (a[i] - mx); if (dx < 0) dx = -dx;
        dy = (b[i] - my); if (dy < 0) dy = -dy;
        if (dx > maxabs) maxabs = dx;
        if (dy > maxabs) maxabs = dy;
      }
      scale = 1.0;
      if (maxabs > 0) scale = 10000.0 / maxabs;
      print n;
      for (i = 1; i <= n; i++) printf("%.15g %.15g\n", (a[i]-mx)*scale, (b[i]-my)*scale);
    }' "$in" > "$tmp"
  mv "$tmp" "$out"
  echo "Wrote: $out"
}

if [[ ${#@} -eq 0 ]]; then
  usage
  exit 1
fi

case "$1" in
  --all)
    if [[ ! -d "${SOURCEDIR}" ]]; then
      echo "Source directory not found: ${SOURCEDIR}" >&2
      exit 1
    fi
    mkdir -p "${OUTDIR}"
    # Iterate files in numeric order by basename (e.g., 1.txt, 2.txt, ...)
    # We list basenames, strip .txt, sort -n, then reconstruct full path.
    {
      for f in "${SOURCEDIR}"/*.txt; do
        [[ -e "$f" ]] || continue
        bn=${f##*/}
        echo "${bn%.txt}"
      done
    } | LC_ALL=C sort -n |
    while IFS= read -r id; do
      infile="${SOURCEDIR}/${id}.txt"
      [[ -f "$infile" ]] || continue
      process_file "$infile"
    done
    ;;
  -n)
    if [[ $# -lt 2 ]]; then
      echo "-n requires an ID argument" >&2
      usage
      exit 1
    fi
    id="$2"
    infile="${SOURCEDIR}/${id}.txt"
    if [[ ! -f "$infile" ]]; then
      echo "File not found: $infile" >&2
      exit 1
    fi
    mkdir -p "${OUTDIR}"
    process_file "$infile"
    ;;
  -h|--help)
    usage
    ;; 
  *)
    echo "Unknown option: $1" >&2
    usage
    exit 1
    ;;
esac
